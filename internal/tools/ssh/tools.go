package ssh

import (
	"context"

	"github.com/giantswarm/mcp-teleport/internal/server"
	"github.com/mark3labs/mcp-go/mcp"
	mcpserver "github.com/mark3labs/mcp-go/server"
)

// RegisterSSHTools registers SSH-related tools with the MCP server
func RegisterSSHTools(s *mcpserver.MCPServer, sc *server.ServerContext) error {
	// teleport_list_ssh_nodes tool
	listSSHNodesTool := mcp.NewTool("teleport_list_ssh_nodes",
		mcp.WithDescription("List SSH nodes available through Teleport"),
		mcp.WithString("loginParam",
			mcp.Description("Remote host login"),
		),
		mcp.WithString("proxyParam",
			mcp.Description("Teleport proxy address"),
		),
		mcp.WithString("userParam",
			mcp.Description("Teleport user, defaults to current local user"),
		),
		mcp.WithString("ttlParam",
			mcp.Description("Minutes to live for a session"),
		),
		mcp.WithString("identityParam",
			mcp.Description("Identity file"),
		),
		mcp.WithBoolean("insecureParam",
			mcp.Description("Do not verify server's certificate and host name. Use only in test environments"),
		),
		mcp.WithBoolean("debugParam",
			mcp.Description("Verbose logging to stdout"),
		),
		// Enhanced parameters for Phase 1
		mcp.WithString("search",
			mcp.Description("List of comma separated search keywords or phrases enclosed in quotations (e.g. foo,bar,\"some phrase\")"),
		),
		mcp.WithString("query",
			mcp.Description("Query by predicate language enclosed in single quotes. Supports ==, !=, &&, and || (e.g. 'labels[\"key1\"] == \"value1\" && labels[\"key2\"] != \"value2\"')"),
		),
		mcp.WithString("labels",
			mcp.Description("List of comma separated labels to filter by (e.g. key1=value1,key2=value2)"),
		),
		mcp.WithBoolean("verbose",
			mcp.Description("One-line output including node UUIDs"),
		),
		mcp.WithBoolean("all",
			mcp.Description("List nodes from all clusters and proxies"),
		),
		mcp.WithString("cluster",
			mcp.Description("Specify the Teleport cluster to connect"),
		),
	)

	s.AddTool(listSSHNodesTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return handleListSSHNodes(ctx, request, sc)
	})

	// teleport_ssh tool
	sshTool := mcp.NewTool("teleport_ssh",
		mcp.WithDescription("Execute a one-time command on a remote SSH node via Teleport. Interactive shell sessions are not supported - you must provide a specific command to execute. Supports both direct hostname targeting (user@hostname) and label selector targeting (user@key=value,key2=value2) for multi-node execution."),
		mcp.WithString("loginParam",
			mcp.Description("Remote host login"),
		),
		mcp.WithString("proxyParam",
			mcp.Description("Teleport proxy address"),
		),
		mcp.WithString("userParam",
			mcp.Description("Teleport user, defaults to current local user"),
		),
		mcp.WithString("ttlParam",
			mcp.Description("Minutes to live for a session"),
		),
		mcp.WithString("identityParam",
			mcp.Description("Identity file"),
		),
		mcp.WithBoolean("insecureParam",
			mcp.Description("Do not verify server's certificate and host name. Use only in test environments"),
		),
		mcp.WithBoolean("debugParam",
			mcp.Description("Verbose logging to stdout"),
		),
		mcp.WithString("destination",
			mcp.Required(),
			mcp.Description("Remote host to connect to. Supports two formats: 1) Direct: 'user@hostname' (targets specific node), 2) Label selector: 'user@key=value,key2=value2' (targets all nodes matching labels). Examples: 'root@web-server-01', 'root@role=worker,env=prod'"),
		),
		mcp.WithString("command",
			mcp.Required(),
			mcp.Description("Command to execute on the remote host. Interactive shell sessions are not supported - a specific command must be provided."),
		),
		mcp.WithNumber("port",
			mcp.Description("SSH port on the remote host"),
		),
		mcp.WithBoolean("verbose",
			mcp.Description("Verbose output"),
		),
		mcp.WithBoolean("forwardAgent",
			mcp.Description("Forward SSH agent to the remote host"),
		),
		// Enhanced parameters for Phase 1
		mcp.WithString("localForward",
			mcp.Description("Forward localhost connections to remote server (format: [bind_address:]port:host:hostport)"),
		),
		mcp.WithString("remoteForward",
			mcp.Description("Forward remote connections to localhost (format: [bind_address:]port:host:hostport)"),
		),
		mcp.WithString("dynamicForward",
			mcp.Description("Forward localhost connections to remote server using SOCKS5 (format: [bind_address:]port)"),
		),
		mcp.WithString("openSSHOptions",
			mcp.Description("OpenSSH options in the format used in the configuration file"),
		),
		mcp.WithString("localCommand",
			mcp.Description("Execute command on localhost after connecting to SSH node"),
		),
		mcp.WithBoolean("noRemoteExec",
			mcp.Description("Don't execute remote command, useful for port forwarding"),
		),
		mcp.WithString("cluster",
			mcp.Description("Specify the Teleport cluster to connect"),
		),
		mcp.WithString("logDir",
			mcp.Description("Directory to log separated command output"),
		),
		mcp.WithBoolean("tty",
			mcp.Description("Allocate TTY"),
		),
	)

	s.AddTool(sshTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return handleSSH(ctx, request, sc)
	})

	// teleport_scp tool
	scpTool := mcp.NewTool("teleport_scp",
		mcp.WithDescription("Transfer files to a remote SSH node"),
		mcp.WithString("loginParam",
			mcp.Description("Remote host login"),
		),
		mcp.WithString("proxyParam",
			mcp.Description("Teleport proxy address"),
		),
		mcp.WithString("userParam",
			mcp.Description("Teleport user, defaults to current local user"),
		),
		mcp.WithString("ttlParam",
			mcp.Description("Minutes to live for a session"),
		),
		mcp.WithString("identityParam",
			mcp.Description("Identity file"),
		),
		mcp.WithBoolean("insecureParam",
			mcp.Description("Do not verify server's certificate and host name. Use only in test environments"),
		),
		mcp.WithBoolean("debugParam",
			mcp.Description("Verbose logging to stdout"),
		),
		mcp.WithString("source",
			mcp.Required(),
			mcp.Description("Source path (local or remote in format [user@]host:path)"),
		),
		mcp.WithString("destination",
			mcp.Required(),
			mcp.Description("Destination path (local or remote in format [user@]host:path)"),
		),
		mcp.WithBoolean("recursive",
			mcp.Description("Recursive copy of subdirectories"),
		),
		mcp.WithBoolean("preserveAttributes",
			mcp.Description("Preserves access and modification times from the original file"),
		),
		mcp.WithNumber("port",
			mcp.Description("Port to connect to on the remote host"),
		),
		mcp.WithString("cluster",
			mcp.Description("Specify the Teleport cluster to connect"),
		),
		mcp.WithBoolean("quiet",
			mcp.Description("Quiet mode"),
		),
	)

	s.AddTool(scpTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return handleSCP(ctx, request, sc)
	})

	// teleport_resolve tool
	resolveTool := mcp.NewTool("teleport_resolve",
		mcp.WithDescription("Resolve an SSH host"),
		mcp.WithString("loginParam",
			mcp.Description("Remote host login"),
		),
		mcp.WithString("proxyParam",
			mcp.Description("Teleport proxy address"),
		),
		mcp.WithString("userParam",
			mcp.Description("Teleport user, defaults to current local user"),
		),
		mcp.WithString("ttlParam",
			mcp.Description("Minutes to live for a session"),
		),
		mcp.WithString("identityParam",
			mcp.Description("Identity file"),
		),
		mcp.WithBoolean("insecureParam",
			mcp.Description("Do not verify server's certificate and host name. Use only in test environments"),
		),
		mcp.WithBoolean("debugParam",
			mcp.Description("Verbose logging to stdout"),
		),
		mcp.WithString("host",
			mcp.Required(),
			mcp.Description("Remote hostname to resolve"),
		),
		mcp.WithBoolean("quiet",
			mcp.Description("Quiet mode"),
		),
	)

	s.AddTool(resolveTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		return handleResolve(ctx, request, sc)
	})

	return nil
}
